{"version":3,"sources":["../../src/backend/index.ts","../../src/backend/generic/actions.ts","../../src/backend/generic/state.ts","../../src/backend/generic/reward.ts","../../src/backend/qlearning.ts","../../src/backend/experience.ts","../../src/backend/optimizerGeneric.ts"],"sourcesContent":["/**\r\n * Backend RL Optimizer for @nikhilayeturi23/rltool\r\n *\r\n * This is a server-side module that provides the Q-learning based RL optimizer.\r\n * It's designed to be used in Node.js environments (e.g., Next.js API routes, Express servers).\r\n *\r\n * DO NOT import this in browser/frontend code - it uses Node.js modules (fs, crypto).\r\n *\r\n * @module @nikhilayeturi23/rltool/backend\r\n *\r\n * @example\r\n * ```typescript\r\n * // Import in server-side code only\r\n * import { optimizeWithRL, type OptimizationResult } from '@nikhilayeturi23/rltool/backend';\r\n * ```\r\n *\r\n * @remarks\r\n * **Important:** Some type names in this module overlap with frontend types\r\n * (e.g., OptimizationResult, IterationLog) but have different structures optimized\r\n * for backend use. Always import from the correct path:\r\n * - **Backend/Server:** `@nikhilayeturi23/rltool/backend`\r\n * - **Frontend/React:** `@nikhilayeturi23/rltool`\r\n */\r\n\r\nexport { optimizeWithRL } from \"./optimizerGeneric\";\r\nexport type {\r\n  GenericFeedback,\r\n  GenericContext,\r\n  GenericOutput,\r\n  GenericObjective,\r\n  OptimizationResult,\r\n  IterationLog\r\n} from \"./optimizerGeneric\";\r\n\r\nexport type {\r\n  QTable,\r\n  QLearningConfig,\r\n  Experience,\r\n  Reward\r\n} from \"./types\";\r\n\r\nexport { GenericAction } from \"./generic/actions\";\r\n\r\nexport type { GenericState } from \"./generic/state\";\r\n\r\nexport type {\r\n  RewardComponents,\r\n  GenericEvaluationResult,\r\n  GenericExecutionMetrics\r\n} from \"./generic/reward\";\r\n","/**\r\n * Generic Action System\r\n *\r\n * Domain-agnostic action selection and application for RL optimization.\r\n * Works with any type of output and objective.\r\n */\r\n\r\n/**\r\n * Generic action types\r\n *\r\n * These are domain-agnostic actions that can be applied to any optimization task.\r\n */\r\nexport enum GenericAction {\r\n  /** Use the generator function (e.g., LLM) to create a new output */\r\n  USE_GENERATOR = \"USE_GENERATOR\",\r\n\r\n  /** Apply a small perturbation to the current output */\r\n  PERTURB_OUTPUT = \"PERTURB_OUTPUT\",\r\n\r\n  /** Simplify the output (reduce complexity) */\r\n  SIMPLIFY = \"SIMPLIFY\",\r\n\r\n  /** Expand the output (add more detail) */\r\n  EXPAND = \"EXPAND\",\r\n\r\n  /** Refine the output (improve quality without changing structure) */\r\n  REFINE = \"REFINE\",\r\n\r\n  /** Reset and start over with generator */\r\n  RESET = \"RESET\",\r\n}\r\n\r\n/**\r\n * Action configuration\r\n */\r\nexport interface ActionConfig {\r\n  type: GenericAction;\r\n  parameters?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Get applicable actions for the current state\r\n *\r\n * @param output - Current output\r\n * @param objective - Optimization objective\r\n * @param iteration - Current iteration number\r\n * @returns List of applicable actions\r\n */\r\nexport function getApplicableActions(\r\n  output: any,\r\n  objective: any,\r\n  iteration: number = 0\r\n): GenericAction[] {\r\n  const actions: GenericAction[] = [];\r\n\r\n  // Generator is always available\r\n  actions.push(GenericAction.USE_GENERATOR);\r\n\r\n  // If we have output, we can apply transformations\r\n  if (output && !isOutputEmpty(output)) {\r\n    actions.push(GenericAction.PERTURB_OUTPUT);\r\n    actions.push(GenericAction.REFINE);\r\n\r\n    // Simplify available if output is complex\r\n    if (getOutputComplexity(output) > 0.5) {\r\n      actions.push(GenericAction.SIMPLIFY);\r\n    }\r\n\r\n    // Expand available if output is simple\r\n    if (getOutputComplexity(output) < 0.7) {\r\n      actions.push(GenericAction.EXPAND);\r\n    }\r\n  }\r\n\r\n  // Reset available after a few iterations\r\n  if (iteration > 3) {\r\n    actions.push(GenericAction.RESET);\r\n  }\r\n\r\n  return actions;\r\n}\r\n\r\n/**\r\n * Apply an action to transform the output\r\n *\r\n * NOTE: Most actions require the generator function, so they return null\r\n * to signal that the generator should be called instead.\r\n *\r\n * @param output - Current output\r\n * @param action - Action to apply\r\n * @param objective - Optimization objective\r\n * @returns Transformed output, or null if generator should be used\r\n */\r\nexport function applyAction(\r\n  output: any,\r\n  action: ActionConfig,\r\n  objective: any\r\n): any | null {\r\n  switch (action.type) {\r\n    case GenericAction.USE_GENERATOR:\r\n    case GenericAction.RESET:\r\n      // Signal that generator should be called\r\n      return null;\r\n\r\n    case GenericAction.PERTURB_OUTPUT:\r\n      return perturbOutput(output, action.parameters);\r\n\r\n    case GenericAction.SIMPLIFY:\r\n      return simplifyOutput(output, action.parameters);\r\n\r\n    case GenericAction.EXPAND:\r\n      return expandOutput(output, action.parameters);\r\n\r\n    case GenericAction.REFINE:\r\n      // Refinement usually requires generator\r\n      return null;\r\n\r\n    default:\r\n      return output;\r\n  }\r\n}\r\n\r\n/**\r\n * Perturb the output (make small random changes)\r\n */\r\nfunction perturbOutput(output: any, parameters?: Record<string, any>): any {\r\n  if (typeof output === \"string\") {\r\n    // For strings, make small modifications\r\n    const words = output.split(\" \");\r\n    if (words.length > 2) {\r\n      // Swap two random words\r\n      const i = Math.floor(Math.random() * words.length);\r\n      const j = Math.floor(Math.random() * words.length);\r\n      [words[i], words[j]] = [words[j], words[i]];\r\n      return words.join(\" \");\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(output)) {\r\n    // For arrays, shuffle slightly\r\n    const result = [...output];\r\n    if (result.length > 2) {\r\n      const i = Math.floor(Math.random() * result.length);\r\n      const j = Math.floor(Math.random() * result.length);\r\n      [result[i], result[j]] = [result[j], result[i]];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // For other types, return unchanged\r\n  return output;\r\n}\r\n\r\n/**\r\n * Simplify the output (reduce complexity)\r\n */\r\nfunction simplifyOutput(output: any, parameters?: Record<string, any>): any {\r\n  if (typeof output === \"string\") {\r\n    // For strings, truncate or summarize\r\n    const maxLength = parameters?.maxLength || output.length * 0.8;\r\n    return output.substring(0, Math.floor(maxLength));\r\n  }\r\n\r\n  if (Array.isArray(output)) {\r\n    // For arrays, reduce size\r\n    const maxSize = parameters?.maxSize || Math.floor(output.length * 0.8);\r\n    return output.slice(0, maxSize);\r\n  }\r\n\r\n  if (typeof output === \"object\" && output !== null) {\r\n    // For objects, remove some properties\r\n    const keys = Object.keys(output);\r\n    const keepCount = Math.floor(keys.length * 0.8);\r\n    const result: any = {};\r\n    for (let i = 0; i < keepCount; i++) {\r\n      result[keys[i]] = output[keys[i]];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n/**\r\n * Expand the output (add more detail)\r\n */\r\nfunction expandOutput(output: any, parameters?: Record<string, any>): any {\r\n  // Expansion usually requires external knowledge (generator/LLM)\r\n  // Return null to signal that generator should be used\r\n  return null;\r\n}\r\n\r\n/**\r\n * Calculate output complexity (0-1 scale)\r\n */\r\nfunction getOutputComplexity(output: any): number {\r\n  if (typeof output === \"string\") {\r\n    // Complexity based on length and structure\r\n    const length = output.length;\r\n    const words = output.split(\" \").length;\r\n    const avgWordLength = words > 0 ? length / words : 0;\r\n\r\n    // Normalize to 0-1 (longer and more complex words = higher complexity)\r\n    const lengthScore = Math.min(length / 1000, 1);\r\n    const wordScore = Math.min(avgWordLength / 10, 1);\r\n    return (lengthScore + wordScore) / 2;\r\n  }\r\n\r\n  if (Array.isArray(output)) {\r\n    // Complexity based on array size and nesting\r\n    const size = output.length;\r\n    const hasNested = output.some(\r\n      (item) => typeof item === \"object\" || Array.isArray(item)\r\n    );\r\n    const sizeScore = Math.min(size / 100, 1);\r\n    const nestScore = hasNested ? 0.5 : 0;\r\n    return (sizeScore + nestScore) / 1.5;\r\n  }\r\n\r\n  if (typeof output === \"object\" && output !== null) {\r\n    // Complexity based on property count and nesting\r\n    const keys = Object.keys(output);\r\n    const keyCount = keys.length;\r\n    const hasNested = keys.some(\r\n      (key) => typeof output[key] === \"object\" || Array.isArray(output[key])\r\n    );\r\n    const keyScore = Math.min(keyCount / 50, 1);\r\n    const nestScore = hasNested ? 0.5 : 0;\r\n    return (keyScore + nestScore) / 1.5;\r\n  }\r\n\r\n  return 0.5; // Default complexity\r\n}\r\n\r\n/**\r\n * Check if output is empty\r\n */\r\nfunction isOutputEmpty(output: any): boolean {\r\n  if (output === null || output === undefined) {\r\n    return true;\r\n  }\r\n  if (typeof output === \"string\") {\r\n    return output.trim().length === 0;\r\n  }\r\n  if (Array.isArray(output)) {\r\n    return output.length === 0;\r\n  }\r\n  if (typeof output === \"object\") {\r\n    return Object.keys(output).length === 0;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Create custom action system\r\n *\r\n * Allows domain-specific actions while maintaining the generic interface\r\n */\r\nexport function createCustomActionSystem(\r\n  getActions: (output: any, objective: any, iteration: number) => string[],\r\n  applyAction: (output: any, action: ActionConfig, objective: any) => any | null\r\n): {\r\n  getApplicableActions: typeof getApplicableActions;\r\n  applyAction: typeof applyAction;\r\n} {\r\n  return {\r\n    getApplicableActions: (output, objective, iteration = 0) => {\r\n      const customActions = getActions(output, objective, iteration);\r\n      // Convert strings to GenericAction enum values\r\n      return customActions.map((action) => action as any as GenericAction);\r\n    },\r\n    applyAction,\r\n  };\r\n}\r\n","/**\r\n * Generic State Extraction\r\n *\r\n * Domain-agnostic state representation for RL optimization.\r\n * Works with any type of output and objective.\r\n */\r\n\r\nimport crypto from \"crypto\";\r\n\r\nexport interface GenericState {\r\n  /** Hash of the objective (for grouping similar problems) */\r\n  objectiveHash: string;\r\n\r\n  /** Hash of the current output */\r\n  outputHash: string;\r\n\r\n  /** Features extracted from the output */\r\n  features: Record<string, any>;\r\n\r\n  /** Metadata about the state */\r\n  metadata: {\r\n    iteration: number;\r\n    timestamp: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Extract state from output and objective (generic version)\r\n *\r\n * @param output - The current output (any type)\r\n * @param objective - The optimization objective\r\n * @param analysis - Analysis result from analyzer function (optional)\r\n * @param iteration - Current iteration number (optional)\r\n * @returns Generic state representation\r\n */\r\nexport function extractGenericState(\r\n  output: any,\r\n  objective: any,\r\n  analysis?: any,\r\n  iteration: number = 0\r\n): GenericState {\r\n  // Hash the objective for grouping similar problems\r\n  const objectiveHash = hashObject(objective);\r\n\r\n  // Hash the output for state identification\r\n  const outputHash = hashObject(output);\r\n\r\n  // Extract features from the output and analysis\r\n  const features: Record<string, any> = {\r\n    // Output-based features\r\n    outputType: typeof output,\r\n    outputLength: getOutputLength(output),\r\n    isEmpty: isOutputEmpty(output),\r\n\r\n    // Analysis-based features (if available)\r\n    ...(analysis || {}),\r\n\r\n    // Objective-based features\r\n    hasConstraints: objective.constraints !== undefined,\r\n    constraintCount: objective.constraints\r\n      ? Object.keys(objective.constraints).length\r\n      : 0,\r\n  };\r\n\r\n  return {\r\n    objectiveHash,\r\n    outputHash,\r\n    features,\r\n    metadata: {\r\n      iteration,\r\n      timestamp: Date.now(),\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a unique key for a state\r\n *\r\n * @param state - The state to generate a key for\r\n * @returns A unique string key representing the state\r\n */\r\nexport function getStateKey(state: GenericState): string {\r\n  // Combine objective hash and key features for state identification\r\n  const keyFeatures = {\r\n    objective: state.objectiveHash,\r\n    output: state.outputHash,\r\n    // Include important features that distinguish states\r\n    outputLength: state.features.outputLength,\r\n    isEmpty: state.features.isEmpty,\r\n  };\r\n\r\n  return hashObject(keyFeatures);\r\n}\r\n\r\n/**\r\n * Compare two states for similarity\r\n *\r\n * @param state1 - First state\r\n * @param state2 - Second state\r\n * @returns Similarity score between 0 and 1\r\n */\r\nexport function compareStates(state1: GenericState, state2: GenericState): number {\r\n  let similarity = 0;\r\n  let totalChecks = 0;\r\n\r\n  // Compare objective hash\r\n  if (state1.objectiveHash === state2.objectiveHash) {\r\n    similarity += 1;\r\n  }\r\n  totalChecks += 1;\r\n\r\n  // Compare output hash\r\n  if (state1.outputHash === state2.outputHash) {\r\n    similarity += 1;\r\n  }\r\n  totalChecks += 1;\r\n\r\n  // Compare features\r\n  const features1 = state1.features;\r\n  const features2 = state2.features;\r\n  const allFeatureKeys = new Set([\r\n    ...Object.keys(features1),\r\n    ...Object.keys(features2),\r\n  ]);\r\n\r\n  for (const key of allFeatureKeys) {\r\n    if (features1[key] === features2[key]) {\r\n      similarity += 1;\r\n    }\r\n    totalChecks += 1;\r\n  }\r\n\r\n  return totalChecks > 0 ? similarity / totalChecks : 0;\r\n}\r\n\r\n/**\r\n * Hash an object to a string (for state identification)\r\n */\r\nfunction hashObject(obj: any): string {\r\n  const str = JSON.stringify(obj, Object.keys(obj).sort());\r\n  return crypto.createHash(\"md5\").update(str).digest(\"hex\").substring(0, 16);\r\n}\r\n\r\n/**\r\n * Get the length/size of output (generic)\r\n */\r\nfunction getOutputLength(output: any): number {\r\n  if (typeof output === \"string\") {\r\n    return output.length;\r\n  }\r\n  if (Array.isArray(output)) {\r\n    return output.length;\r\n  }\r\n  if (typeof output === \"object\" && output !== null) {\r\n    return Object.keys(output).length;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Check if output is empty (generic)\r\n */\r\nfunction isOutputEmpty(output: any): boolean {\r\n  if (output === null || output === undefined) {\r\n    return true;\r\n  }\r\n  if (typeof output === \"string\") {\r\n    return output.trim().length === 0;\r\n  }\r\n  if (Array.isArray(output)) {\r\n    return output.length === 0;\r\n  }\r\n  if (typeof output === \"object\") {\r\n    return Object.keys(output).length === 0;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Create a custom state extractor\r\n *\r\n * Allows domain-specific state extraction while maintaining the generic interface\r\n */\r\nexport function createCustomStateExtractor(\r\n  featureExtractor: (output: any, objective: any, analysis?: any) => Record<string, any>\r\n): (output: any, objective: any, analysis?: any, iteration?: number) => GenericState {\r\n  return (output, objective, analysis, iteration = 0) => {\r\n    const objectiveHash = hashObject(objective);\r\n    const outputHash = hashObject(output);\r\n    const features = featureExtractor(output, objective, analysis);\r\n\r\n    return {\r\n      objectiveHash,\r\n      outputHash,\r\n      features,\r\n      metadata: {\r\n        iteration,\r\n        timestamp: Date.now(),\r\n      },\r\n    };\r\n  };\r\n}\r\n","/**\r\n * Generic Reward Calculation\r\n *\r\n * Domain-agnostic reward calculation for RL optimization.\r\n * Works with any type of output, objective, and evaluation result.\r\n */\r\n\r\nexport interface GenericEvaluationResult {\r\n  passed: boolean;\r\n  feedback?: {\r\n    code: string;\r\n    message: string;\r\n    fix: string;\r\n  };\r\n}\r\n\r\nexport interface GenericExecutionMetrics {\r\n  executionTime?: number;\r\n  outputSize?: number;\r\n  expectedSize?: number;\r\n  hasErrors: boolean;\r\n  customMetrics?: Record<string, number>;\r\n}\r\n\r\nexport interface RewardComponents {\r\n  total: number;\r\n  constraintScore: number;\r\n  qualityScore: number;\r\n  details: string[];\r\n}\r\n\r\n/**\r\n * Calculate reward for any optimization task\r\n *\r\n * @param output - The generated output (any type)\r\n * @param objective - The optimization objective\r\n * @param evaluation - Evaluation result from domain-specific evaluator\r\n * @param metrics - Execution metrics (optional)\r\n * @returns Reward components\r\n */\r\nexport function calculateGenericReward(\r\n  output: any,\r\n  objective: any,\r\n  evaluation: GenericEvaluationResult,\r\n  metrics: GenericExecutionMetrics\r\n): RewardComponents {\r\n  let constraintScore = 0;\r\n  let qualityScore = 0;\r\n  const details: string[] = [];\r\n\r\n  // 1. CONSTRAINT SATISFACTION (0-60 points)\r\n  if (evaluation.passed) {\r\n    constraintScore = 60;\r\n    details.push(\"✓ All constraints satisfied (+60)\");\r\n  } else {\r\n    constraintScore = 0;\r\n    details.push(`✗ Constraints failed: ${evaluation.feedback?.code || 'UNKNOWN'} (+0)`);\r\n  }\r\n\r\n  // 2. EXECUTION QUALITY (0-40 points)\r\n  if (metrics.hasErrors) {\r\n    qualityScore -= 30;\r\n    details.push(\"✗ Execution errors (-30)\");\r\n  } else {\r\n    qualityScore += 10;\r\n    details.push(\"✓ No errors (+10)\");\r\n  }\r\n\r\n  // 3. PERFORMANCE METRICS (bonus/penalty)\r\n  if (metrics.executionTime !== undefined) {\r\n    if (metrics.executionTime < 50) {\r\n      qualityScore += 15;\r\n      details.push(`✓ Fast execution: ${metrics.executionTime}ms (+15)`);\r\n    } else if (metrics.executionTime < 100) {\r\n      qualityScore += 10;\r\n      details.push(`✓ Good execution: ${metrics.executionTime}ms (+10)`);\r\n    } else if (metrics.executionTime > 1000) {\r\n      qualityScore -= 10;\r\n      details.push(`✗ Slow execution: ${metrics.executionTime}ms (-10)`);\r\n    }\r\n  }\r\n\r\n  // 4. SIZE/COMPLEXITY METRICS (bonus/penalty)\r\n  if (metrics.outputSize !== undefined && metrics.expectedSize !== undefined) {\r\n    const sizeDiff = Math.abs(metrics.outputSize - metrics.expectedSize);\r\n    const sizeRatio = sizeDiff / metrics.expectedSize;\r\n\r\n    if (sizeRatio < 0.1) {\r\n      qualityScore += 10;\r\n      details.push(\"✓ Optimal size (+10)\");\r\n    } else if (sizeRatio > 0.5) {\r\n      qualityScore -= 5;\r\n      details.push(\"✗ Size mismatch (-5)\");\r\n    }\r\n  }\r\n\r\n  // 5. CUSTOM METRICS (if provided)\r\n  if (metrics.customMetrics) {\r\n    for (const [metric, value] of Object.entries(metrics.customMetrics)) {\r\n      qualityScore += value;\r\n      details.push(`Custom metric ${metric}: ${value > 0 ? '+' : ''}${value}`);\r\n    }\r\n  }\r\n\r\n  const total = constraintScore + qualityScore;\r\n\r\n  return {\r\n    total,\r\n    constraintScore,\r\n    qualityScore,\r\n    details,\r\n  };\r\n}\r\n\r\n/**\r\n * Validate semantic correctness (generic version)\r\n *\r\n * This is a placeholder - domain-specific implementations should override this\r\n * or provide their own semantic validation in the evaluator.\r\n */\r\nexport function validateGenericSemantics(\r\n  output: any,\r\n  objective: any,\r\n  analysis: any\r\n): { semanticsMatch: boolean; issues: string[] } {\r\n  // Generic semantic validation - can be overridden by domain-specific logic\r\n  const issues: string[] = [];\r\n\r\n  // Basic check: output exists and is not empty\r\n  if (!output || (typeof output === 'string' && output.trim().length === 0)) {\r\n    issues.push(\"Output is empty or null\");\r\n  }\r\n\r\n  // Check if output type matches expected type (if specified in objective)\r\n  if (objective.expectedType) {\r\n    const actualType = typeof output;\r\n    if (actualType !== objective.expectedType) {\r\n      issues.push(`Expected type ${objective.expectedType}, got ${actualType}`);\r\n    }\r\n  }\r\n\r\n  // Check if output meets minimum quality criteria (if specified)\r\n  if (objective.minQuality && analysis.quality !== undefined) {\r\n    if (analysis.quality < objective.minQuality) {\r\n      issues.push(`Quality ${analysis.quality} below minimum ${objective.minQuality}`);\r\n    }\r\n  }\r\n\r\n  return {\r\n    semanticsMatch: issues.length === 0,\r\n    issues,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate reward with custom reward function\r\n *\r\n * Allows domain-specific reward calculation while maintaining the generic interface\r\n */\r\nexport function calculateCustomReward(\r\n  output: any,\r\n  objective: any,\r\n  evaluation: GenericEvaluationResult,\r\n  metrics: GenericExecutionMetrics,\r\n  customRewardFn?: (output: any, objective: any, evaluation: GenericEvaluationResult, metrics: GenericExecutionMetrics) => number\r\n): RewardComponents {\r\n  if (customRewardFn) {\r\n    const customScore = customRewardFn(output, objective, evaluation, metrics);\r\n    return {\r\n      total: customScore,\r\n      constraintScore: evaluation.passed ? 60 : 0,\r\n      qualityScore: customScore - (evaluation.passed ? 60 : 0),\r\n      details: [`Custom reward function: ${customScore}`],\r\n    };\r\n  }\r\n\r\n  return calculateGenericReward(output, objective, evaluation, metrics);\r\n}\r\n","import {\r\n  QLearningConfig,\r\n  PersistedQTable,\r\n} from \"./types\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\n\r\n// Generic Q-Table type (state -> action -> Q-value)\r\ntype QTable = Map<string, Map<string, number>>;\r\n\r\n// Default hyperparameters\r\nconst DEFAULT_CONFIG: QLearningConfig = {\r\n  alpha: 0.1, // Learning rate\r\n  gamma: 0.9, // Discount factor\r\n  epsilon: 0.2, // Exploration rate\r\n  epsilonDecay: 0.995, // Decay per query\r\n  epsilonMin: 0.05, // Minimum exploration\r\n  maxQTableSize: 10000, // Max state-action pairs\r\n  maxExperiences: 1000, // Max experiences\r\n};\r\n\r\n// Global Q-table (persisted across requests)\r\nlet qtable: QTable = new Map();\r\nlet config: QLearningConfig = { ...DEFAULT_CONFIG };\r\nlet queriesProcessed = 0;\r\n\r\n// Q-table file path\r\nconst QTABLE_PATH = path.join(process.cwd(), \"data\", \"qtable.json\");\r\n\r\n/**\r\n * Load Q-table from disk on startup\r\n */\r\nexport async function loadQTable(): Promise<void> {\r\n  try {\r\n    await fs.mkdir(path.dirname(QTABLE_PATH), { recursive: true });\r\n    const data = await fs.readFile(QTABLE_PATH, \"utf-8\");\r\n    const persisted: PersistedQTable = JSON.parse(data);\r\n\r\n    // Convert persisted format to Map\r\n    qtable = new Map();\r\n    for (const [stateKey, actions] of Object.entries(persisted.qtable)) {\r\n      const actionMap = new Map<string, number>();\r\n      for (const [action, qValue] of Object.entries(actions)) {\r\n        actionMap.set(action, qValue);\r\n      }\r\n      qtable.set(stateKey, actionMap);\r\n    }\r\n\r\n    config = persisted.hyperparams;\r\n    console.log(`[Q-Learning] Loaded Q-table with ${qtable.size} states`);\r\n  } catch (error) {\r\n    console.log(\"[Q-Learning] No existing Q-table found, starting fresh\");\r\n    qtable = new Map();\r\n  }\r\n}\r\n\r\n/**\r\n * Save Q-table to disk\r\n */\r\nexport async function saveQTable(): Promise<void> {\r\n  try {\r\n    // Convert Map to plain object for JSON serialization\r\n    const plainQTable: Record<string, Record<string, number>> = {};\r\n    for (const [stateKey, actions] of qtable.entries()) {\r\n      plainQTable[stateKey] = {};\r\n      for (const [action, qValue] of actions.entries()) {\r\n        plainQTable[stateKey][action] = qValue;\r\n      }\r\n    }\r\n\r\n    const persisted: PersistedQTable = {\r\n      version: 1,\r\n      updatedAt: new Date().toISOString(),\r\n      hyperparams: config,\r\n      qtable: plainQTable,\r\n    };\r\n\r\n    await fs.mkdir(path.dirname(QTABLE_PATH), { recursive: true });\r\n    await fs.writeFile(QTABLE_PATH, JSON.stringify(persisted, null, 2));\r\n    console.log(`[Q-Learning] Saved Q-table with ${qtable.size} states`);\r\n  } catch (error) {\r\n    console.error(\"[Q-Learning] Failed to save Q-table:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Get Q-value for state-action pair\r\n */\r\nexport function getQValue(stateKey: string, action: string): number {\r\n  if (!qtable.has(stateKey)) {\r\n    return getInitialQValue(action);\r\n  }\r\n\r\n  const actionMap = qtable.get(stateKey)!;\r\n  if (!actionMap.has(action)) {\r\n    return getInitialQValue(action);\r\n  }\r\n\r\n  return actionMap.get(action)!;\r\n}\r\n\r\n/**\r\n * Set Q-value for state-action pair\r\n */\r\nexport function setQValue(\r\n  stateKey: string,\r\n  action: string,\r\n  value: number\r\n): void {\r\n  if (!qtable.has(stateKey)) {\r\n    qtable.set(stateKey, new Map());\r\n  }\r\n\r\n  const actionMap = qtable.get(stateKey)!;\r\n  actionMap.set(action, value);\r\n\r\n  // LRU eviction if Q-table is too large\r\n  if (qtable.size > config.maxQTableSize) {\r\n    evictOldestEntry();\r\n  }\r\n}\r\n\r\n/**\r\n * Update Q-value using Bellman equation\r\n * Q(s,a) = Q(s,a) + α[r + γ·max(Q(s',a')) - Q(s,a)]\r\n */\r\nexport function updateQValue(\r\n  stateKey: string,\r\n  action: string,\r\n  reward: number,\r\n  nextStateKey: string,\r\n  applicableActions: string[]\r\n): void {\r\n  const currentQ = getQValue(stateKey, action);\r\n\r\n  // Find max Q-value for next state\r\n  const maxNextQ = Math.max(\r\n    ...applicableActions.map((a) => getQValue(nextStateKey, a))\r\n  );\r\n\r\n  // Bellman update\r\n  const newQ = currentQ + config.alpha * (reward + config.gamma * maxNextQ - currentQ);\r\n\r\n  setQValue(stateKey, action, newQ);\r\n}\r\n\r\n/**\r\n * Select action using epsilon-greedy strategy\r\n */\r\nexport function selectAction(\r\n  stateKey: string,\r\n  applicableActions: string[]\r\n): string {\r\n  // Exploration: random action\r\n  if (Math.random() < config.epsilon) {\r\n    const randomIndex = Math.floor(Math.random() * applicableActions.length);\r\n    return applicableActions[randomIndex];\r\n  }\r\n\r\n  // Exploitation: best Q-value\r\n  let bestAction = applicableActions[0];\r\n  let bestQValue = getQValue(stateKey, bestAction);\r\n\r\n  for (const action of applicableActions) {\r\n    const qValue = getQValue(stateKey, action);\r\n    if (qValue > bestQValue) {\r\n      bestQValue = qValue;\r\n      bestAction = action;\r\n    }\r\n  }\r\n\r\n  return bestAction;\r\n}\r\n\r\n/**\r\n * Decay epsilon (reduce exploration over time)\r\n */\r\nexport function decayEpsilon(): void {\r\n  queriesProcessed++;\r\n  config.epsilon = Math.max(\r\n    config.epsilonMin,\r\n    config.epsilon * config.epsilonDecay\r\n  );\r\n\r\n  console.log(`[Q-Learning] Epsilon decayed to ${config.epsilon.toFixed(3)} (queries: ${queriesProcessed})`);\r\n}\r\n\r\n/**\r\n * Get initial Q-value for new state-action pairs\r\n */\r\nfunction getInitialQValue(action: string): number {\r\n  // Slight bias toward generator/LLM policy initially\r\n  if (action === \"USE_GENERATOR\" || action === \"USE_LLM_POLICY\") {\r\n    return 0.5;\r\n  }\r\n  return 0.0;\r\n}\r\n\r\n/**\r\n * Evict oldest entry from Q-table (simple LRU)\r\n */\r\nfunction evictOldestEntry(): void {\r\n  const firstKey = qtable.keys().next().value;\r\n  if (firstKey) {\r\n    qtable.delete(firstKey);\r\n    console.log(\"[Q-Learning] Evicted oldest Q-table entry (LRU)\");\r\n  }\r\n}\r\n\r\n/**\r\n * Get Q-table statistics\r\n */\r\nexport function getQTableStats(): {\r\n  size: number;\r\n  epsilon: number;\r\n  queriesProcessed: number;\r\n  topStateActions: Array<{ stateKey: string; action: string; qValue: number }>;\r\n} {\r\n  // Get top 10 state-action pairs by Q-value\r\n  const allPairs: Array<{ stateKey: string; action: string; qValue: number }> = [];\r\n\r\n  for (const [stateKey, actions] of qtable.entries()) {\r\n    for (const [action, qValue] of actions.entries()) {\r\n      allPairs.push({ stateKey, action, qValue });\r\n    }\r\n  }\r\n\r\n  allPairs.sort((a, b) => b.qValue - a.qValue);\r\n  const topStateActions = allPairs.slice(0, 10);\r\n\r\n  return {\r\n    size: qtable.size,\r\n    epsilon: config.epsilon,\r\n    queriesProcessed,\r\n    topStateActions,\r\n  };\r\n}\r\n\r\n/**\r\n * Reset Q-table (for testing or debugging)\r\n */\r\nexport function resetQTable(): void {\r\n  qtable = new Map();\r\n  config = { ...DEFAULT_CONFIG };\r\n  queriesProcessed = 0;\r\n  console.log(\"[Q-Learning] Q-table reset\");\r\n}\r\n\r\n// Initialize Q-table on module load\r\nloadQTable().catch((error) => {\r\n  console.error(\"[Q-Learning] Failed to load Q-table:\", error);\r\n});\r\n","import { Experience } from \"./types\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\nimport crypto from \"crypto\";\r\n\r\n// Experience replay buffer\r\nlet experiences: Experience[] = [];\r\n\r\n// Experience buffer file path\r\nconst EXPERIENCES_PATH = path.join(process.cwd(), \"data\", \"experiences.json\");\r\n\r\nconst MAX_EXPERIENCES = 1000;\r\n\r\n/**\r\n * Load experiences from disk on startup\r\n */\r\nexport async function loadExperiences(): Promise<void> {\r\n  try {\r\n    await fs.mkdir(path.dirname(EXPERIENCES_PATH), { recursive: true });\r\n    const data = await fs.readFile(EXPERIENCES_PATH, \"utf-8\");\r\n    experiences = JSON.parse(data);\r\n    console.log(`[Experience] Loaded ${experiences.length} experiences`);\r\n  } catch (error) {\r\n    console.log(\"[Experience] No existing experiences found, starting fresh\");\r\n    experiences = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Save experiences to disk\r\n */\r\nexport async function saveExperiences(): Promise<void> {\r\n  try {\r\n    await fs.mkdir(path.dirname(EXPERIENCES_PATH), { recursive: true});\r\n    await fs.writeFile(\r\n      EXPERIENCES_PATH,\r\n      JSON.stringify(experiences, null, 2)\r\n    );\r\n    console.log(`[Experience] Saved ${experiences.length} experiences`);\r\n  } catch (error) {\r\n    console.error(\"[Experience] Failed to save experiences:\", error);\r\n  }\r\n}\r\n\r\n/**\r\n * Add experience to replay buffer\r\n */\r\nexport function addExperience(experience: Omit<Experience, \"id\">): Experience {\r\n  const exp: Experience = {\r\n    ...experience,\r\n    id: generateExperienceId(),\r\n  };\r\n\r\n  experiences.push(exp);\r\n\r\n  // Circular buffer: remove oldest if exceeds max\r\n  if (experiences.length > MAX_EXPERIENCES) {\r\n    experiences.shift();\r\n  }\r\n\r\n  return exp;\r\n}\r\n\r\n/**\r\n * Get experience by ID\r\n */\r\nexport function getExperienceById(id: string): Experience | undefined {\r\n  return experiences.find((exp) => exp.id === id);\r\n}\r\n\r\n/**\r\n * Get all experiences\r\n */\r\nexport function getAllExperiences(): Experience[] {\r\n  return [...experiences];\r\n}\r\n\r\n/**\r\n * Get recent experiences (last N)\r\n */\r\nexport function getRecentExperiences(count: number): Experience[] {\r\n  return experiences.slice(-count);\r\n}\r\n\r\n/**\r\n * Sample random batch of experiences for offline learning\r\n */\r\nexport function sampleExperiences(batchSize: number): Experience[] {\r\n  if (experiences.length <= batchSize) {\r\n    return [...experiences];\r\n  }\r\n\r\n  const sampled: Experience[] = [];\r\n  const indices = new Set<number>();\r\n\r\n  while (sampled.length < batchSize) {\r\n    const randomIndex = Math.floor(Math.random() * experiences.length);\r\n    if (!indices.has(randomIndex)) {\r\n      indices.add(randomIndex);\r\n      sampled.push(experiences[randomIndex]);\r\n    }\r\n  }\r\n\r\n  return sampled;\r\n}\r\n\r\n/**\r\n * Get experiences by objective hash\r\n */\r\nexport function getExperiencesByObjective(\r\n  objectiveHash: string\r\n): Experience[] {\r\n  return experiences.filter((exp) => exp.objectiveHash === objectiveHash);\r\n}\r\n\r\n/**\r\n * Calculate average reward for recent experiences\r\n */\r\nexport function getAverageReward(count: number = 50): number {\r\n  if (experiences.length === 0) return 0;\r\n\r\n  const recent = getRecentExperiences(count);\r\n  const totalReward = recent.reduce((sum, exp) => sum + exp.reward, 0);\r\n\r\n  return totalReward / recent.length;\r\n}\r\n\r\n/**\r\n * Get experience statistics\r\n */\r\nexport function getExperienceStats(): {\r\n  totalExperiences: number;\r\n  averageReward: number;\r\n  successRate: number;\r\n  recentRewards: number[];\r\n} {\r\n  const recent = getRecentExperiences(20);\r\n\r\n  return {\r\n    totalExperiences: experiences.length,\r\n    averageReward: getAverageReward(50),\r\n    successRate:\r\n      experiences.length > 0\r\n        ? experiences.filter((exp) => exp.terminal).length / experiences.length\r\n        : 0,\r\n    recentRewards: recent.map((exp) => exp.reward),\r\n  };\r\n}\r\n\r\n/**\r\n * Clear all experiences (for testing/debugging)\r\n */\r\nexport function clearExperiences(): void {\r\n  experiences = [];\r\n  console.log(\"[Experience] Cleared all experiences\");\r\n}\r\n\r\n/**\r\n * Generate unique experience ID\r\n */\r\nfunction generateExperienceId(): string {\r\n  return crypto.randomBytes(8).toString(\"hex\");\r\n}\r\n\r\n// Initialize experiences on module load\r\nloadExperiences().catch((error) => {\r\n  console.error(\"[Experience] Failed to load experiences:\", error);\r\n});\r\n","/**\r\n * Fully Generic RL Optimizer using Q-Learning\r\n *\r\n * This optimizer is completely domain-agnostic and can optimize ANY type of output.\r\n * It uses only generic helper functions - NO SQL-specific code.\r\n */\r\n\r\nimport { GenericAction, getApplicableActions, applyAction } from \"./generic/actions\";\r\nimport { extractGenericState, getStateKey, GenericState } from \"./generic/state\";\r\nimport {\r\n  calculateGenericReward,\r\n  validateGenericSemantics,\r\n  GenericEvaluationResult,\r\n  GenericExecutionMetrics,\r\n  RewardComponents,\r\n} from \"./generic/reward\";\r\nimport {\r\n  selectAction,\r\n  updateQValue,\r\n  decayEpsilon,\r\n  saveQTable,\r\n} from \"./qlearning\";\r\nimport { addExperience, saveExperiences } from \"./experience\";\r\n\r\n/**\r\n * Generic types for any domain\r\n */\r\nexport type GenericFeedback = {\r\n  code: string;\r\n  message: string;\r\n  fix: string;\r\n};\r\n\r\nexport type GenericContext = any;\r\nexport type GenericOutput = any;\r\nexport type GenericObjective = any;\r\n\r\nexport interface IterationLog {\r\n  iteration: number;\r\n  output: GenericOutput;\r\n  action: string;\r\n  state: string;\r\n  evaluation: GenericEvaluationResult;\r\n  semanticMatch: boolean;\r\n  semanticIssues: string[];\r\n  reward: RewardComponents;\r\n  converged: boolean;\r\n}\r\n\r\nexport interface OptimizationResult {\r\n  output: GenericOutput;\r\n  iterations: number;\r\n  finalReward: number;\r\n  iterationLogs: IterationLog[];\r\n}\r\n\r\n/**\r\n * Fully Generic RL Optimizer\r\n *\r\n * This function can optimize ANYTHING using Q-learning.\r\n * It's completely independent from SQL or any specific domain.\r\n *\r\n * @param objective - The optimization objective (any structure)\r\n * @param context - Domain-specific context (e.g., schema, rules, constraints)\r\n * @param generateOutput - Function to generate/improve output\r\n * @param evaluateOutput - Function to evaluate if output meets constraints\r\n * @param analyzeOutput - Function to analyze output structure\r\n * @param maxIterations - Maximum number of iterations\r\n * @param customConfig - Optional custom configuration\r\n * @returns Optimization result\r\n */\r\nexport async function optimizeWithRL(\r\n  objective: GenericObjective,\r\n  context: GenericContext,\r\n  generateOutput: (input: {\r\n    objective: GenericObjective;\r\n    context: GenericContext;\r\n    previousOutput: GenericOutput | null;\r\n    feedback: GenericFeedback | null;\r\n  }) => Promise<GenericOutput>,\r\n  evaluateOutput: (\r\n    output: GenericOutput,\r\n    analysis: any,\r\n    objective: GenericObjective\r\n  ) => GenericEvaluationResult,\r\n  analyzeOutput: (output: GenericOutput) => any,\r\n  maxIterations: number = 10,\r\n  customConfig?: {\r\n    customRewardFn?: (\r\n      output: any,\r\n      objective: any,\r\n      evaluation: GenericEvaluationResult,\r\n      metrics: GenericExecutionMetrics\r\n    ) => RewardComponents;\r\n    customStateExtractor?: (output: any, objective: any, analysis?: any, iteration?: number) => GenericState;\r\n    customActionSelector?: (output: any, objective: any, iteration: number) => GenericAction[];\r\n    persistLearning?: boolean; // NEW: Enable/disable file persistence (default: false for serverless compatibility)\r\n  }\r\n): Promise<OptimizationResult> {\r\n  console.log(\"\\n========== GENERIC Q-LEARNING OPTIMIZER ==========\");\r\n  console.log(`Optimizing for objective: ${JSON.stringify(objective).substring(0, 100)}...`);\r\n\r\n  let currentOutput: GenericOutput = null;\r\n  let previousFeedback: GenericFeedback | null = null;\r\n  let finalReward = 0;\r\n  const iterationLogs: IterationLog[] = [];\r\n\r\n  for (let iteration = 1; iteration <= maxIterations; iteration++) {\r\n    console.log(`\\n--- Iteration ${iteration}/${maxIterations} ---`);\r\n\r\n    // STEP 1: GENERATE OR TRANSFORM OUTPUT\r\n    if (iteration === 1 || currentOutput === null) {\r\n      // First iteration: generate initial output\r\n      console.log(\"[RL] Generating initial output...\");\r\n      currentOutput = await generateOutput({\r\n        objective,\r\n        context,\r\n        previousOutput: null,\r\n        feedback: null,\r\n      });\r\n      console.log(`[RL] Initial output generated (type: ${typeof currentOutput})`);\r\n    }\r\n\r\n    // STEP 2: EXTRACT STATE\r\n    const analysis = analyzeOutput(currentOutput);\r\n    const currentState = customConfig?.customStateExtractor\r\n      ? customConfig.customStateExtractor(currentOutput, objective, analysis, iteration)\r\n      : extractGenericState(currentOutput, objective, analysis, iteration);\r\n    const currentStateKey = getStateKey(currentState);\r\n\r\n    console.log(`[RL] State: ${currentStateKey.substring(0, 50)}...`);\r\n    console.log(`[RL] Features:`, Object.keys(currentState.features).slice(0, 5));\r\n\r\n    // STEP 3: GET APPLICABLE ACTIONS\r\n    const applicableActions = customConfig?.customActionSelector\r\n      ? customConfig.customActionSelector(currentOutput, objective, iteration)\r\n      : getApplicableActions(currentOutput, objective, iteration);\r\n\r\n    console.log(`[RL] Applicable actions: ${applicableActions.join(\", \")}`);\r\n\r\n    // STEP 4: SELECT ACTION (epsilon-greedy from Q-learning)\r\n    const selectedAction = selectAction(currentStateKey, applicableActions);\r\n    console.log(`[RL] Selected action: ${selectedAction}`);\r\n\r\n    // STEP 5: APPLY ACTION\r\n    let nextOutput: GenericOutput;\r\n\r\n    if (selectedAction === GenericAction.USE_GENERATOR || selectedAction === GenericAction.RESET) {\r\n      // Use generator function\r\n      console.log(\"[RL] Using generator to create new output...\");\r\n      nextOutput = await generateOutput({\r\n        objective,\r\n        context,\r\n        previousOutput: currentOutput,\r\n        feedback: previousFeedback,\r\n      });\r\n      console.log(`[RL] New output generated (type: ${typeof nextOutput})`);\r\n    } else {\r\n      // Apply transformation action\r\n      console.log(`[RL] Applying transformation: ${selectedAction}...`);\r\n      const transformed = applyAction(\r\n        currentOutput,\r\n        { type: selectedAction as GenericAction },\r\n        objective\r\n      );\r\n\r\n      if (transformed === null) {\r\n        // Action requires generator\r\n        console.log(\"[RL] Transformation requires generator, using it...\");\r\n        nextOutput = await generateOutput({\r\n          objective,\r\n          context,\r\n          previousOutput: currentOutput,\r\n          feedback: previousFeedback,\r\n        });\r\n      } else {\r\n        nextOutput = transformed;\r\n        console.log(\"[RL] Transformation applied\");\r\n      }\r\n    }\r\n\r\n    // STEP 6: EVALUATE OUTPUT\r\n    const nextAnalysis = analyzeOutput(nextOutput);\r\n    const evaluationResult = evaluateOutput(nextOutput, nextAnalysis, objective);\r\n\r\n    console.log(`[RL] Evaluation: ${evaluationResult.passed ? \"✓ PASS\" : \"✗ FAIL\"}`);\r\n    if (!evaluationResult.passed && evaluationResult.feedback) {\r\n      console.log(`[RL] Feedback: ${evaluationResult.feedback.message}`);\r\n    }\r\n\r\n    // STEP 7: SEMANTIC VALIDATION\r\n    const semanticValidation = validateGenericSemantics(nextOutput, objective, nextAnalysis);\r\n    console.log(\r\n      `[RL] Semantic Match: ${semanticValidation.semanticsMatch ? \"✅ YES\" : \"❌ NO\"}`\r\n    );\r\n    if (!semanticValidation.semanticsMatch) {\r\n      console.log(`[RL] Semantic Issues:`, semanticValidation.issues);\r\n    }\r\n\r\n    // STEP 8: CALCULATE REWARD\r\n    const executionMetrics: GenericExecutionMetrics = {\r\n      executionTime: nextAnalysis.executionTime,\r\n      outputSize: nextAnalysis.size || nextAnalysis.length,\r\n      expectedSize: objective.expectedSize,\r\n      hasErrors: !evaluationResult.passed,\r\n      customMetrics: nextAnalysis.customMetrics,\r\n    };\r\n\r\n    let reward = customConfig?.customRewardFn\r\n      ? customConfig.customRewardFn(nextOutput, objective, evaluationResult, executionMetrics)\r\n      : calculateGenericReward(nextOutput, objective, evaluationResult, executionMetrics);\r\n\r\n    // Apply semantic penalty if output doesn't match intent\r\n    if (!semanticValidation.semanticsMatch) {\r\n      const semanticPenalty = semanticValidation.issues.length * -15;\r\n      console.log(`[RL] Applying semantic penalty: ${semanticPenalty}`);\r\n      reward = {\r\n        ...reward,\r\n        qualityScore: reward.qualityScore + semanticPenalty,\r\n        total: reward.total + semanticPenalty,\r\n      };\r\n    }\r\n\r\n    console.log(\r\n      `[RL] Reward: ${reward.total} (constraint: ${reward.constraintScore}, quality: ${reward.qualityScore})`\r\n    );\r\n    finalReward = reward.total;\r\n\r\n    // STEP 9: EXTRACT NEXT STATE\r\n    const nextState = customConfig?.customStateExtractor\r\n      ? customConfig.customStateExtractor(nextOutput, objective, nextAnalysis, iteration)\r\n      : extractGenericState(nextOutput, objective, nextAnalysis, iteration);\r\n    const nextStateKey = getStateKey(nextState);\r\n\r\n    // STEP 10: UPDATE Q-VALUE (Bellman equation)\r\n    updateQValue(\r\n      currentStateKey,\r\n      selectedAction,\r\n      reward.total,\r\n      nextStateKey,\r\n      applicableActions\r\n    );\r\n\r\n    // STEP 11: STORE EXPERIENCE\r\n    const experience = addExperience({\r\n      stateKey: currentStateKey,\r\n      action: selectedAction,\r\n      reward: reward.total,\r\n      nextStateKey: nextStateKey,\r\n      terminal: evaluationResult.passed,\r\n      timestamp: new Date().toISOString(),\r\n      objectiveHash: currentState.objectiveHash,\r\n    });\r\n\r\n    console.log(`[RL] Stored experience: ${experience.id}`);\r\n\r\n    // STEP 12: LOG ITERATION\r\n    iterationLogs.push({\r\n      iteration,\r\n      output: nextOutput,\r\n      action: selectedAction,\r\n      state: currentStateKey.substring(0, 80),\r\n      evaluation: evaluationResult,\r\n      semanticMatch: semanticValidation.semanticsMatch,\r\n      semanticIssues: semanticValidation.issues || [],\r\n      reward,\r\n      converged:\r\n        evaluationResult.passed &&\r\n        semanticValidation.semanticsMatch &&\r\n        reward.total >= 100,\r\n    });\r\n\r\n    // STEP 13: CHECK CONVERGENCE\r\n    if (\r\n      evaluationResult.passed &&\r\n      semanticValidation.semanticsMatch &&\r\n      reward.total >= 100\r\n    ) {\r\n      console.log(\"\\n✅ CONVERGED - Output meets all constraints AND semantic intent!\");\r\n      console.log(`Final output (type: ${typeof nextOutput})`);\r\n\r\n      // Save Q-table and experiences (only if persistence enabled)\r\n      if (customConfig?.persistLearning) {\r\n        saveQTable().catch((err) => console.error(\"Failed to save Q-table:\", err));\r\n        saveExperiences().catch((err) =>\r\n          console.error(\"Failed to save experiences:\", err)\r\n        );\r\n      }\r\n      decayEpsilon();\r\n\r\n      return {\r\n        output: nextOutput,\r\n        iterations: iteration,\r\n        finalReward: reward.total,\r\n        iterationLogs,\r\n      };\r\n    }\r\n\r\n    // Partial convergence\r\n    if (\r\n      evaluationResult.passed &&\r\n      !semanticValidation.semanticsMatch &&\r\n      iteration === maxIterations\r\n    ) {\r\n      console.log(\"\\n⚠️  PARTIAL CONVERGENCE - Constraints pass but semantic issues remain\");\r\n      console.log(\"Semantic issues:\", semanticValidation.issues);\r\n    }\r\n\r\n    // STEP 14: UPDATE FOR NEXT ITERATION\r\n    currentOutput = nextOutput;\r\n    previousFeedback = evaluationResult.feedback || null;\r\n  }\r\n\r\n  // Failed to converge\r\n  console.log(\"\\n❌ Max iterations reached without full convergence\");\r\n\r\n  // Save progress (only if persistence enabled)\r\n  if (customConfig?.persistLearning) {\r\n    saveQTable().catch((err) => console.error(\"Failed to save Q-table:\", err));\r\n    saveExperiences().catch((err) => console.error(\"Failed to save experiences:\", err));\r\n  }\r\n  decayEpsilon();\r\n\r\n  return {\r\n    output: currentOutput,\r\n    iterations: maxIterations,\r\n    finalReward,\r\n    iterationLogs,\r\n  };\r\n}\r\n"],"mappings":"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","names":["GenericAction","isOutputEmpty","crypto","isOutputEmpty","path","fs","import_promises","import_path","import_crypto","path","fs","crypto"]}